/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ANFStatement
 */
export interface ANFStatement {
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'id'?: string;
    /**
     * 
     * @type {Measure}
     * @memberof ANFStatement
     */
    'time'?: Measure;
    /**
     * 
     * @type {Participant}
     * @memberof ANFStatement
     */
    'subjectOfRecord'?: Participant;
    /**
     * 
     * @type {Array<Practitioner>}
     * @memberof ANFStatement
     */
    'authors'?: Array<Practitioner>;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'subjectOfInformation'?: string;
    /**
     * 
     * @type {Array<AssociatedStatement>}
     * @memberof ANFStatement
     */
    'associatedStatement'?: Array<AssociatedStatement>;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'topic'?: string;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'type'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof ANFStatement
     */
    'created'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof ANFStatement
     */
    'modified'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'modifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ANFStatement
     */
    'status'?: ANFStatementStatusEnum;
    /**
     * 
     * @type {PerformanceCircumstance}
     * @memberof ANFStatement
     */
    'performanceCircumstance'?: PerformanceCircumstance;
    /**
     * 
     * @type {RequestCircumstance}
     * @memberof ANFStatement
     */
    'requestCircumstance'?: RequestCircumstance;
    /**
     * 
     * @type {NarrativeCircumstance}
     * @memberof ANFStatement
     */
    'narrativeCircumstance'?: NarrativeCircumstance;
}

export const ANFStatementStatusEnum = {
    StatusUnspecified: 'STATUS_UNSPECIFIED',
    StatusActive: 'STATUS_ACTIVE',
    StatusDeleted: 'STATUS_DELETED',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type ANFStatementStatusEnum = typeof ANFStatementStatusEnum[keyof typeof ANFStatementStatusEnum];

/**
 * 
 * @export
 * @interface AnfStatementConnector
 */
export interface AnfStatementConnector {
    /**
     * 
     * @type {ANFStatement}
     * @memberof AnfStatementConnector
     */
    'anfStatement'?: ANFStatement;
    /**
     * 
     * @type {string}
     * @memberof AnfStatementConnector
     */
    'anfStatementType'?: AnfStatementConnectorAnfStatementTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AnfStatementConnector
     */
    'anfOperatorType'?: AnfStatementConnectorAnfOperatorTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AnfStatementConnector
     */
    'operatorValue'?: string;
}

export const AnfStatementConnectorAnfStatementTypeEnum = {
    AnfStatementTypeUnspecified: 'ANF_STATEMENT_TYPE_UNSPECIFIED',
    AnfStatementTypeMain: 'ANF_STATEMENT_TYPE_MAIN',
    AnfStatementTypeAssociated: 'ANF_STATEMENT_TYPE_ASSOCIATED',
    AnfStatementUserQuestion: 'ANF_STATEMENT_USER_QUESTION',
    AnfStatementTypeNotApplicable: 'ANF_STATEMENT_TYPE_NOT_APPLICABLE',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type AnfStatementConnectorAnfStatementTypeEnum = typeof AnfStatementConnectorAnfStatementTypeEnum[keyof typeof AnfStatementConnectorAnfStatementTypeEnum];
export const AnfStatementConnectorAnfOperatorTypeEnum = {
    AnfOperatorTypeUnspecified: 'ANF_OPERATOR_TYPE_UNSPECIFIED',
    AnfOperatorTypeEqual: 'ANF_OPERATOR_TYPE_EQUAL',
    AnfOperatorTypeNotEqual: 'ANF_OPERATOR_TYPE_NOT_EQUAL',
    AnfOperatorTypeGreaterThan: 'ANF_OPERATOR_TYPE_GREATER_THAN',
    AnfOperatorTypeGreaterThanOrEqual: 'ANF_OPERATOR_TYPE_GREATER_THAN_OR_EQUAL',
    AnfOperatorTypeLessThan: 'ANF_OPERATOR_TYPE_LESS_THAN',
    AnfOperatorTypeLessThanOrEqual: 'ANF_OPERATOR_TYPE_LESS_THAN_OR_EQUAL',
    AnfOperatorTypeContains: 'ANF_OPERATOR_TYPE_CONTAINS',
    AnfOperatorTypeNotContains: 'ANF_OPERATOR_TYPE_NOT_CONTAINS',
    AnfOperatorTypeIn: 'ANF_OPERATOR_TYPE_IN',
    AnfOperatorTypeNotIn: 'ANF_OPERATOR_TYPE_NOT_IN',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type AnfStatementConnectorAnfOperatorTypeEnum = typeof AnfStatementConnectorAnfOperatorTypeEnum[keyof typeof AnfStatementConnectorAnfOperatorTypeEnum];

/**
 * 
 * @export
 * @interface AnswerValue
 */
export interface AnswerValue {
    /**
     * 
     * @type {number}
     * @memberof AnswerValue
     */
    'valueInteger'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnswerValue
     */
    'valueDouble'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnswerValue
     */
    'valueString'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AnswerValue
     */
    'valueBoolean'?: boolean;
    /**
     * 
     * @type {Coding}
     * @memberof AnswerValue
     */
    'valueCoding'?: Coding;
}
/**
 * 
 * @export
 * @interface AssociatedStatement
 */
export interface AssociatedStatement {
    /**
     * 
     * @type {string}
     * @memberof AssociatedStatement
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssociatedStatement
     */
    'semantic'?: string;
}
/**
 * 
 * @export
 * @interface ClientQuestionnaireData
 */
export interface ClientQuestionnaireData {
    /**
     * 
     * @type {Array<QuestionnaireData>}
     * @memberof ClientQuestionnaireData
     */
    'questionnaireData'?: Array<QuestionnaireData>;
    /**
     * 
     * @type {string}
     * @memberof ClientQuestionnaireData
     */
    'organizationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientQuestionnaireData
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientQuestionnaireData
     */
    'ruleId'?: string;
}
/**
 * 
 * @export
 * @interface ClientQuestionnaireDataRequest
 */
export interface ClientQuestionnaireDataRequest {
    /**
     * 
     * @type {ClientQuestionnaireData}
     * @memberof ClientQuestionnaireDataRequest
     */
    'clientQuestionnaireData'?: ClientQuestionnaireData;
}
/**
 * 
 * @export
 * @interface Code
 */
export interface Code {
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'system'?: string;
    /**
     * 
     * @type {string}
     * @memberof Code
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Coding
 */
export interface Coding {
    /**
     * 
     * @type {string}
     * @memberof Coding
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coding
     */
    'system'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coding
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coding
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Coding
     */
    'display'?: string;
}
/**
 * 
 * @export
 * @interface Extension
 */
export interface Extension {
    /**
     * 
     * @type {string}
     * @memberof Extension
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Extension
     */
    'valueDecimal'?: number;
    /**
     * 
     * @type {Coding}
     * @memberof Extension
     */
    'valueCodeableConcept'?: Coding;
}
/**
 * 
 * @export
 * @interface GetQuestionnaireListRequest
 */
export interface GetQuestionnaireListRequest {
    /**
     * 
     * @type {string}
     * @memberof GetQuestionnaireListRequest
     */
    'id'?: string;
    /**
     * 
     * @type {Pagination}
     * @memberof GetQuestionnaireListRequest
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {boolean}
     * @memberof GetQuestionnaireListRequest
     */
    'updateAnswers'?: boolean;
}
/**
 * 
 * @export
 * @interface Measure
 */
export interface Measure {
    /**
     * 
     * @type {string}
     * @memberof Measure
     */
    'upperBound'?: string;
    /**
     * 
     * @type {string}
     * @memberof Measure
     */
    'lowerBound'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Measure
     */
    'includeUpperBound'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Measure
     */
    'includeLowerBound'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Measure
     */
    'semantic'?: string;
    /**
     * 
     * @type {string}
     * @memberof Measure
     */
    'resolution'?: string;
}
/**
 * 
 * @export
 * @interface NarrativeCircumstance
 */
export interface NarrativeCircumstance {
    /**
     * 
     * @type {Measure}
     * @memberof NarrativeCircumstance
     */
    'timing'?: Measure;
    /**
     * 
     * @type {Array<string>}
     * @memberof NarrativeCircumstance
     */
    'purpose'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NarrativeCircumstance
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pagination
     */
    'sortAscending'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'totalRecords'?: number;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'practitionerValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface PerformanceCircumstance
 */
export interface PerformanceCircumstance {
    /**
     * 
     * @type {Measure}
     * @memberof PerformanceCircumstance
     */
    'timing'?: Measure;
    /**
     * 
     * @type {Array<string>}
     * @memberof PerformanceCircumstance
     */
    'purpose'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PerformanceCircumstance
     */
    'status'?: string;
    /**
     * 
     * @type {Measure}
     * @memberof PerformanceCircumstance
     */
    'result'?: Measure;
    /**
     * 
     * @type {string}
     * @memberof PerformanceCircumstance
     */
    'healthRisk'?: string;
    /**
     * 
     * @type {Measure}
     * @memberof PerformanceCircumstance
     */
    'normalRange'?: Measure;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof PerformanceCircumstance
     */
    'participant'?: Array<Participant>;
}
/**
 * 
 * @export
 * @interface Practitioner
 */
export interface Practitioner {
    /**
     * 
     * @type {string}
     * @memberof Practitioner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Practitioner
     */
    'practitionerValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof Practitioner
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface Questionnaire
 */
export interface Questionnaire {
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'resourceType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'status'?: QuestionnaireStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'purpose'?: string;
    /**
     * 
     * @type {Array<QuestionnaireItem>}
     * @memberof Questionnaire
     */
    'item'?: Array<QuestionnaireItem>;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'ruleId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Questionnaire
     */
    'ruleQuestionId'?: Array<string>;
    /**
     * 
     * @type {Timestamp}
     * @memberof Questionnaire
     */
    'created'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof Questionnaire
     */
    'modified'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Questionnaire
     */
    'modifier'?: string;
}

export const QuestionnaireStatusEnum = {
    Draft: 'draft',
    Active: 'active',
    Retired: 'retired',
    Unknown: 'unknown',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type QuestionnaireStatusEnum = typeof QuestionnaireStatusEnum[keyof typeof QuestionnaireStatusEnum];

/**
 * 
 * @export
 * @interface QuestionnaireData
 */
export interface QuestionnaireData {
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'questionJsonId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'questionAnfJson'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'rulesEngineConfig'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof QuestionnaireData
     */
    'created'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof QuestionnaireData
     */
    'modified'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireData
     */
    'modifier'?: string;
}
/**
 * 
 * @export
 * @interface QuestionnaireDataRequest
 */
export interface QuestionnaireDataRequest {
    /**
     * 
     * @type {QuestionnaireData}
     * @memberof QuestionnaireDataRequest
     */
    'questionnaireData'?: QuestionnaireData;
}
/**
 * 
 * @export
 * @interface QuestionnaireEnableWhen
 */
export interface QuestionnaireEnableWhen {
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireEnableWhen
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireEnableWhen
     */
    'operator'?: string;
    /**
     * 
     * @type {Coding}
     * @memberof QuestionnaireEnableWhen
     */
    'answerCoding'?: Coding;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireEnableWhen
     */
    'answerInteger'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireEnableWhen
     */
    'answerDouble'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireEnableWhen
     */
    'answerBoolean'?: boolean;
}
/**
 * 
 * @export
 * @interface QuestionnaireItem
 */
export interface QuestionnaireItem {
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireItem
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireItem
     */
    'linkId'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireItem
     */
    'text'?: string;
    /**
     * 
     * @type {Array<QuestionnaireEnableWhen>}
     * @memberof QuestionnaireItem
     */
    'enableWhen'?: Array<QuestionnaireEnableWhen>;
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireItem
     */
    'enableBehavior'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireItem
     */
    'required'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireItem
     */
    'repeats'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireItem
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {Array<Code>}
     * @memberof QuestionnaireItem
     */
    'code'?: Array<Code>;
    /**
     * 
     * @type {Array<QuestionnaireItemExtension>}
     * @memberof QuestionnaireItem
     */
    'extension'?: Array<QuestionnaireItemExtension>;
    /**
     * 
     * @type {Array<QuestionnaireItemAnswerOption>}
     * @memberof QuestionnaireItem
     */
    'answerOption'?: Array<QuestionnaireItemAnswerOption>;
    /**
     * 
     * @type {Array<QuestionnaireItemInitial>}
     * @memberof QuestionnaireItem
     */
    'initial'?: Array<QuestionnaireItemInitial>;
    /**
     * 
     * @type {Array<AnfStatementConnector>}
     * @memberof QuestionnaireItem
     */
    'anfStatementConnector'?: Array<AnfStatementConnector>;
    /**
     * 
     * @type {Array<AnswerValue>}
     * @memberof QuestionnaireItem
     */
    'answer'?: Array<AnswerValue>;
}
/**
 * 
 * @export
 * @interface QuestionnaireItemAnswerOption
 */
export interface QuestionnaireItemAnswerOption {
    /**
     * 
     * @type {Coding}
     * @memberof QuestionnaireItemAnswerOption
     */
    'valueCoding'?: Coding;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireItemAnswerOption
     */
    'initialSelected'?: boolean;
    /**
     * 
     * @type {Array<Extension>}
     * @memberof QuestionnaireItemAnswerOption
     */
    'extension'?: Array<Extension>;
}
/**
 * 
 * @export
 * @interface QuestionnaireItemExtension
 */
export interface QuestionnaireItemExtension {
    /**
     * 
     * @type {string}
     * @memberof QuestionnaireItemExtension
     */
    'url'?: string;
    /**
     * 
     * @type {ValueCodeableConcept}
     * @memberof QuestionnaireItemExtension
     */
    'valueCodeableConcept'?: ValueCodeableConcept;
    /**
     * 
     * @type {Coding}
     * @memberof QuestionnaireItemExtension
     */
    'valueCoding'?: Coding;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireItemExtension
     */
    'valueInteger'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireItemExtension
     */
    'valueDecimal'?: number;
}
/**
 * 
 * @export
 * @interface QuestionnaireItemInitial
 */
export interface QuestionnaireItemInitial {
    /**
     * 
     * @type {boolean}
     * @memberof QuestionnaireItemInitial
     */
    'valueBoolean'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireItemInitial
     */
    'valueInteger'?: number;
    /**
     * 
     * @type {number}
     * @memberof QuestionnaireItemInitial
     */
    'valueDecimal'?: number;
}
/**
 * 
 * @export
 * @interface QuestionnaireRequest
 */
export interface QuestionnaireRequest {
    /**
     * 
     * @type {Questionnaire}
     * @memberof QuestionnaireRequest
     */
    'questionnaire'?: Questionnaire;
}
/**
 * 
 * @export
 * @interface Questionnaires
 */
export interface Questionnaires {
    /**
     * 
     * @type {Array<Questionnaire>}
     * @memberof Questionnaires
     */
    'questionnaires'?: Array<Questionnaire>;
    /**
     * 
     * @type {Pagination}
     * @memberof Questionnaires
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface Repetition
 */
export interface Repetition {
    /**
     * 
     * @type {Timestamp}
     * @memberof Repetition
     */
    'periodStart'?: Timestamp;
    /**
     * 
     * @type {number}
     * @memberof Repetition
     */
    'periodDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repetition
     */
    'periodDurationType'?: RepetitionPeriodDurationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Repetition
     */
    'eventFrequency'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repetition
     */
    'eventFrequencyType'?: RepetitionEventFrequencyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Repetition
     */
    'eventSeparation'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repetition
     */
    'eventSeparationType'?: RepetitionEventSeparationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Repetition
     */
    'eventDuration'?: number;
    /**
     * 
     * @type {string}
     * @memberof Repetition
     */
    'eventDurationType'?: RepetitionEventDurationTypeEnum;
}

export const RepetitionPeriodDurationTypeEnum = {
    DurationTypeNotSpecified: 'DURATION_TYPE_NOT_SPECIFIED',
    DurationTypeMilliseconds: 'DURATION_TYPE_MILLISECONDS',
    DurationTypeSeconds: 'DURATION_TYPE_SECONDS',
    DurationTypeMinutes: 'DURATION_TYPE_MINUTES',
    DurationTypeHours: 'DURATION_TYPE_HOURS',
    DurationTypeDays: 'DURATION_TYPE_DAYS',
    DurationTypeWeeks: 'DURATION_TYPE_WEEKS',
    DurationTypeMonths: 'DURATION_TYPE_MONTHS',
    DurationTypeYears: 'DURATION_TYPE_YEARS',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type RepetitionPeriodDurationTypeEnum = typeof RepetitionPeriodDurationTypeEnum[keyof typeof RepetitionPeriodDurationTypeEnum];
export const RepetitionEventFrequencyTypeEnum = {
    DurationTypeNotSpecified: 'DURATION_TYPE_NOT_SPECIFIED',
    DurationTypeMilliseconds: 'DURATION_TYPE_MILLISECONDS',
    DurationTypeSeconds: 'DURATION_TYPE_SECONDS',
    DurationTypeMinutes: 'DURATION_TYPE_MINUTES',
    DurationTypeHours: 'DURATION_TYPE_HOURS',
    DurationTypeDays: 'DURATION_TYPE_DAYS',
    DurationTypeWeeks: 'DURATION_TYPE_WEEKS',
    DurationTypeMonths: 'DURATION_TYPE_MONTHS',
    DurationTypeYears: 'DURATION_TYPE_YEARS',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type RepetitionEventFrequencyTypeEnum = typeof RepetitionEventFrequencyTypeEnum[keyof typeof RepetitionEventFrequencyTypeEnum];
export const RepetitionEventSeparationTypeEnum = {
    DurationTypeNotSpecified: 'DURATION_TYPE_NOT_SPECIFIED',
    DurationTypeMilliseconds: 'DURATION_TYPE_MILLISECONDS',
    DurationTypeSeconds: 'DURATION_TYPE_SECONDS',
    DurationTypeMinutes: 'DURATION_TYPE_MINUTES',
    DurationTypeHours: 'DURATION_TYPE_HOURS',
    DurationTypeDays: 'DURATION_TYPE_DAYS',
    DurationTypeWeeks: 'DURATION_TYPE_WEEKS',
    DurationTypeMonths: 'DURATION_TYPE_MONTHS',
    DurationTypeYears: 'DURATION_TYPE_YEARS',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type RepetitionEventSeparationTypeEnum = typeof RepetitionEventSeparationTypeEnum[keyof typeof RepetitionEventSeparationTypeEnum];
export const RepetitionEventDurationTypeEnum = {
    DurationTypeNotSpecified: 'DURATION_TYPE_NOT_SPECIFIED',
    DurationTypeMilliseconds: 'DURATION_TYPE_MILLISECONDS',
    DurationTypeSeconds: 'DURATION_TYPE_SECONDS',
    DurationTypeMinutes: 'DURATION_TYPE_MINUTES',
    DurationTypeHours: 'DURATION_TYPE_HOURS',
    DurationTypeDays: 'DURATION_TYPE_DAYS',
    DurationTypeWeeks: 'DURATION_TYPE_WEEKS',
    DurationTypeMonths: 'DURATION_TYPE_MONTHS',
    DurationTypeYears: 'DURATION_TYPE_YEARS',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type RepetitionEventDurationTypeEnum = typeof RepetitionEventDurationTypeEnum[keyof typeof RepetitionEventDurationTypeEnum];

/**
 * 
 * @export
 * @interface RequestCircumstance
 */
export interface RequestCircumstance {
    /**
     * 
     * @type {Measure}
     * @memberof RequestCircumstance
     */
    'timing'?: Measure;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestCircumstance
     */
    'purpose'?: Array<string>;
    /**
     * 
     * @type {Array<AssociatedStatement>}
     * @memberof RequestCircumstance
     */
    'conditionalTrigger'?: Array<AssociatedStatement>;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof RequestCircumstance
     */
    'requestedParticipant'?: Array<Participant>;
    /**
     * 
     * @type {string}
     * @memberof RequestCircumstance
     */
    'priority'?: RequestCircumstancePriorityEnum;
    /**
     * 
     * @type {Measure}
     * @memberof RequestCircumstance
     */
    'requestedResult'?: Measure;
    /**
     * 
     * @type {Repetition}
     * @memberof RequestCircumstance
     */
    'repetition'?: Repetition;
}

export const RequestCircumstancePriorityEnum = {
    Routine: 'ROUTINE',
    Stat: 'STAT',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type RequestCircumstancePriorityEnum = typeof RequestCircumstancePriorityEnum[keyof typeof RequestCircumstancePriorityEnum];

/**
 * 
 * @export
 * @interface SubmissionResponse
 */
export interface SubmissionResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SubmissionResponse
     */
    'success'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubmissionResponse
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface SystemQuestionnaireData
 */
export interface SystemQuestionnaireData {
    /**
     * 
     * @type {Array<QuestionnaireData>}
     * @memberof SystemQuestionnaireData
     */
    'questionnaireData'?: Array<QuestionnaireData>;
}
/**
 * 
 * @export
 * @interface Timestamp
 */
export interface Timestamp {
    /**
     * 
     * @type {number}
     * @memberof Timestamp
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Timestamp
     */
    'nanos'?: number;
}
/**
 * 
 * @export
 * @interface UserQuestionnaireData
 */
export interface UserQuestionnaireData {
    /**
     * 
     * @type {string}
     * @memberof UserQuestionnaireData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserQuestionnaireData
     */
    'patientId'?: string;
    /**
     * 
     * @type {Array<Questionnaire>}
     * @memberof UserQuestionnaireData
     */
    'questionnaireData'?: Array<Questionnaire>;
}
/**
 * 
 * @export
 * @interface UserQuestionnaireDataRequest
 */
export interface UserQuestionnaireDataRequest {
    /**
     * 
     * @type {UserQuestionnaireData}
     * @memberof UserQuestionnaireDataRequest
     */
    'userQuestionnaireData'?: UserQuestionnaireData;
}
/**
 * 
 * @export
 * @interface UserQuestionnaireDataResponse
 */
export interface UserQuestionnaireDataResponse {
    /**
     * 
     * @type {Array<UserQuestionnaireData>}
     * @memberof UserQuestionnaireDataResponse
     */
    'list'?: Array<UserQuestionnaireData>;
    /**
     * 
     * @type {Pagination}
     * @memberof UserQuestionnaireDataResponse
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ValueCodeableConcept
 */
export interface ValueCodeableConcept {
    /**
     * 
     * @type {string}
     * @memberof ValueCodeableConcept
     */
    'text'?: string;
    /**
     * 
     * @type {Array<Coding>}
     * @memberof ValueCodeableConcept
     */
    'coding'?: Array<Coding>;
}

/**
 * OpenCdxRestQuestionnaireControllerApi - axios parameter creator
 * @export
 */
export const OpenCdxRestQuestionnaireControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClientQuestionnaireData: async (clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientQuestionnaireDataRequest' is not null or undefined
            assertParamExists('createClientQuestionnaireData', 'clientQuestionnaireDataRequest', clientQuestionnaireDataRequest)
            const localVarPath = `/client/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientQuestionnaireDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionnaire: async (questionnaireRequest: QuestionnaireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireRequest' is not null or undefined
            assertParamExists('createQuestionnaire', 'questionnaireRequest', questionnaireRequest)
            const localVarPath = `/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionnaireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionnaireData: async (questionnaireDataRequest: QuestionnaireDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireDataRequest' is not null or undefined
            assertParamExists('createQuestionnaireData', 'questionnaireDataRequest', questionnaireDataRequest)
            const localVarPath = `/system/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionnaireDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserQuestionnaireDataRequest} userQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserQuestionnaireData: async (userQuestionnaireDataRequest: UserQuestionnaireDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userQuestionnaireDataRequest' is not null or undefined
            assertParamExists('createUserQuestionnaireData', 'userQuestionnaireDataRequest', userQuestionnaireDataRequest)
            const localVarPath = `/user/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userQuestionnaireDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteClientQuestionnaire', 'id', id)
            const localVarPath = `/client/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuestionnaire', 'id', id)
            const localVarPath = `/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystemQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSystemQuestionnaire', 'id', id)
            const localVarPath = `/system/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getClientQuestionnaire', 'id', id)
            const localVarPath = `/client/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientQuestionnaireDataList: async (getQuestionnaireListRequest: GetQuestionnaireListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getQuestionnaireListRequest' is not null or undefined
            assertParamExists('getClientQuestionnaireDataList', 'getQuestionnaireListRequest', getQuestionnaireListRequest)
            const localVarPath = `/client/questionnaire/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getQuestionnaireListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [updateAnswers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaire: async (id: string, updateAnswers?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getQuestionnaire', 'id', id)
            const localVarPath = `/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (updateAnswers !== undefined) {
                localVarQueryParameter['updateAnswers'] = updateAnswers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaireDataList: async (getQuestionnaireListRequest: GetQuestionnaireListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getQuestionnaireListRequest' is not null or undefined
            assertParamExists('getQuestionnaireDataList', 'getQuestionnaireListRequest', getQuestionnaireListRequest)
            const localVarPath = `/system/questionnaire/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getQuestionnaireListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaires: async (getQuestionnaireListRequest: GetQuestionnaireListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getQuestionnaireListRequest' is not null or undefined
            assertParamExists('getQuestionnaires', 'getQuestionnaireListRequest', getQuestionnaireListRequest)
            const localVarPath = `/questionnaire/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getQuestionnaireListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSystemQuestionnaire', 'id', id)
            const localVarPath = `/system/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserQuestionnaire', 'id', id)
            const localVarPath = `/user/questionnaire/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuestionnaireDataList: async (getQuestionnaireListRequest: GetQuestionnaireListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getQuestionnaireListRequest' is not null or undefined
            assertParamExists('getUserQuestionnaireDataList', 'getQuestionnaireListRequest', getQuestionnaireListRequest)
            const localVarPath = `/user/questionnaire/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getQuestionnaireListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshQuestionnaire: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refreshQuestionnaire', 'id', id)
            const localVarPath = `/questionnaire/refresh/{Id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientQuestionnaireData: async (clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientQuestionnaireDataRequest' is not null or undefined
            assertParamExists('updateClientQuestionnaireData', 'clientQuestionnaireDataRequest', clientQuestionnaireDataRequest)
            const localVarPath = `/client/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientQuestionnaireDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionnaire: async (questionnaireRequest: QuestionnaireRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireRequest' is not null or undefined
            assertParamExists('updateQuestionnaire', 'questionnaireRequest', questionnaireRequest)
            const localVarPath = `/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionnaireRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionnaireData: async (questionnaireDataRequest: QuestionnaireDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionnaireDataRequest' is not null or undefined
            assertParamExists('updateQuestionnaireData', 'questionnaireDataRequest', questionnaireDataRequest)
            const localVarPath = `/system/questionnaire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionnaireDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdxRestQuestionnaireControllerApi - functional programming interface
 * @export
 */
export const OpenCdxRestQuestionnaireControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdxRestQuestionnaireControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClientQuestionnaireData(clientQuestionnaireDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.createClientQuestionnaireData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionnaire(questionnaireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.createQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionnaireData(questionnaireDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.createQuestionnaireData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserQuestionnaireDataRequest} userQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserQuestionnaireData(userQuestionnaireDataRequest: UserQuestionnaireDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserQuestionnaireData(userQuestionnaireDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.createUserQuestionnaireData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClientQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClientQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.deleteClientQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.deleteQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSystemQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSystemQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.deleteSystemQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientQuestionnaireData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getClientQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientQuestionnaireData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientQuestionnaireDataList(getQuestionnaireListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getClientQuestionnaireDataList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [updateAnswers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionnaire(id: string, updateAnswers?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionnaire(id, updateAnswers, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemQuestionnaireData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionnaireDataList(getQuestionnaireListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getQuestionnaireDataList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionnaires(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaires>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionnaires(getQuestionnaireListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getQuestionnaires']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemQuestionnaireData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getSystemQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserQuestionnaireData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getUserQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserQuestionnaireDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserQuestionnaireDataList(getQuestionnaireListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.getUserQuestionnaireDataList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshQuestionnaire(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshQuestionnaire(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.refreshQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClientQuestionnaireData(clientQuestionnaireDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.updateClientQuestionnaireData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Questionnaire>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestionnaire(questionnaireRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.updateQuestionnaire']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmissionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestionnaireData(questionnaireDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestQuestionnaireControllerApi.updateQuestionnaireData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenCdxRestQuestionnaireControllerApi - factory interface
 * @export
 */
export const OpenCdxRestQuestionnaireControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdxRestQuestionnaireControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.createClientQuestionnaireData(clientQuestionnaireDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: any): AxiosPromise<Questionnaire> {
            return localVarFp.createQuestionnaire(questionnaireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.createQuestionnaireData(questionnaireDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserQuestionnaireDataRequest} userQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserQuestionnaireData(userQuestionnaireDataRequest: UserQuestionnaireDataRequest, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.createUserQuestionnaireData(userQuestionnaireDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClientQuestionnaire(id: string, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.deleteClientQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionnaire(id: string, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.deleteQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSystemQuestionnaire(id: string, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.deleteSystemQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientQuestionnaire(id: string, options?: any): AxiosPromise<ClientQuestionnaireData> {
            return localVarFp.getClientQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: any): AxiosPromise<ClientQuestionnaireData> {
            return localVarFp.getClientQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [updateAnswers] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaire(id: string, updateAnswers?: boolean, options?: any): AxiosPromise<Questionnaire> {
            return localVarFp.getQuestionnaire(id, updateAnswers, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: any): AxiosPromise<SystemQuestionnaireData> {
            return localVarFp.getQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionnaires(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: any): AxiosPromise<Questionnaires> {
            return localVarFp.getQuestionnaires(getQuestionnaireListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemQuestionnaire(id: string, options?: any): AxiosPromise<SystemQuestionnaireData> {
            return localVarFp.getSystemQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuestionnaire(id: string, options?: any): AxiosPromise<UserQuestionnaireData> {
            return localVarFp.getUserQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: any): AxiosPromise<UserQuestionnaireDataResponse> {
            return localVarFp.getUserQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshQuestionnaire(id: string, options?: any): AxiosPromise<Questionnaire> {
            return localVarFp.refreshQuestionnaire(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.updateClientQuestionnaireData(clientQuestionnaireDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnaireRequest} questionnaireRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: any): AxiosPromise<Questionnaire> {
            return localVarFp.updateQuestionnaire(questionnaireRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QuestionnaireDataRequest} questionnaireDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: any): AxiosPromise<SubmissionResponse> {
            return localVarFp.updateQuestionnaireData(questionnaireDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdxRestQuestionnaireControllerApi - object-oriented interface
 * @export
 * @class OpenCdxRestQuestionnaireControllerApi
 * @extends {BaseAPI}
 */
export class OpenCdxRestQuestionnaireControllerApi extends BaseAPI {
    /**
     * 
     * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public createClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).createClientQuestionnaireData(clientQuestionnaireDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnaireRequest} questionnaireRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public createQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).createQuestionnaire(questionnaireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnaireDataRequest} questionnaireDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public createQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).createQuestionnaireData(questionnaireDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserQuestionnaireDataRequest} userQuestionnaireDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public createUserQuestionnaireData(userQuestionnaireDataRequest: UserQuestionnaireDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).createUserQuestionnaireData(userQuestionnaireDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public deleteClientQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).deleteClientQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public deleteQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).deleteQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public deleteSystemQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).deleteSystemQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getClientQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getClientQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getClientQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getClientQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [updateAnswers] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getQuestionnaire(id: string, updateAnswers?: boolean, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getQuestionnaire(id, updateAnswers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getQuestionnaires(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getQuestionnaires(getQuestionnaireListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getSystemQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getSystemQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getUserQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getUserQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GetQuestionnaireListRequest} getQuestionnaireListRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public getUserQuestionnaireDataList(getQuestionnaireListRequest: GetQuestionnaireListRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).getUserQuestionnaireDataList(getQuestionnaireListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public refreshQuestionnaire(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).refreshQuestionnaire(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClientQuestionnaireDataRequest} clientQuestionnaireDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public updateClientQuestionnaireData(clientQuestionnaireDataRequest: ClientQuestionnaireDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).updateClientQuestionnaireData(clientQuestionnaireDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnaireRequest} questionnaireRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public updateQuestionnaire(questionnaireRequest: QuestionnaireRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).updateQuestionnaire(questionnaireRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QuestionnaireDataRequest} questionnaireDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestQuestionnaireControllerApi
     */
    public updateQuestionnaireData(questionnaireDataRequest: QuestionnaireDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestQuestionnaireControllerApiFp(this.configuration).updateQuestionnaireData(questionnaireDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}




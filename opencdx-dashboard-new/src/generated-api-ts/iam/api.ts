/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'countryId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'addressPurpose'?: AddressAddressPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'address3'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'postalCode'?: string;
}

export const AddressAddressPurposeEnum = {
    Location: 'LOCATION',
    Mailing: 'MAILING',
    Primary: 'PRIMARY',
    Secondary: 'SECONDARY',
    Billing: 'BILLING',
    Shipping: 'SHIPPING',
    Work: 'WORK',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type AddressAddressPurposeEnum = typeof AddressAddressPurposeEnum[keyof typeof AddressAddressPurposeEnum];

/**
 * 
 * @export
 * @interface AnomalyDetectionData
 */
export interface AnomalyDetectionData {
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'dataAccessPattern'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof AnomalyDetectionData
     */
    'timeStamp'?: Timestamp;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnomalyDetectionData
     */
    'anomaliesDetected'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'sourceIp'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'location'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnomalyDetectionData
     */
    'affectedSystems'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AnomalyDetectionData
     */
    'severityLevel'?: string;
}
/**
 * 
 * @export
 * @interface AnomalyDetectionDataRequest
 */
export interface AnomalyDetectionDataRequest {
    /**
     * 
     * @type {AnomalyDetectionData}
     * @memberof AnomalyDetectionDataRequest
     */
    'anomalyDetectionData'?: AnomalyDetectionData;
}
/**
 * 
 * @export
 * @interface AuthorizationControlData
 */
export interface AuthorizationControlData {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationControlData
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationControlData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationControlData
     */
    'dataAccessLevel'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationControlData
     */
    'accessGrantedBy'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthorizationControlData
     */
    'accessScopes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationControlData
     */
    'accessValidityPeriod'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizationControlData
     */
    'isTemporaryAccess'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthorizationControlData
     */
    'conditionalAccessParams'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AuthorizationControlDataRequest
 */
export interface AuthorizationControlDataRequest {
    /**
     * 
     * @type {AuthorizationControlData}
     * @memberof AuthorizationControlDataRequest
     */
    'authorizationControlData'?: AuthorizationControlData;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'oldPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPassword'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    'newPasswordConfirmation'?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordResponse
 */
export interface ChangePasswordResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof ChangePasswordResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface ContactInfo
 */
export interface ContactInfo {
    /**
     * 
     * @type {FullName}
     * @memberof ContactInfo
     */
    'name'?: FullName;
    /**
     * 
     * @type {string}
     * @memberof ContactInfo
     */
    'patientId'?: string;
    /**
     * 
     * @type {Array<Address>}
     * @memberof ContactInfo
     */
    'addresses'?: Array<Address>;
    /**
     * 
     * @type {Array<PhoneNumber>}
     * @memberof ContactInfo
     */
    'phoneNumbers'?: Array<PhoneNumber>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof ContactInfo
     */
    'emails'?: Array<EmailAddress>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationRequest
 */
export interface CreateOrganizationRequest {
    /**
     * 
     * @type {Organization}
     * @memberof CreateOrganizationRequest
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface CreateOrganizationResponse
 */
export interface CreateOrganizationResponse {
    /**
     * 
     * @type {Organization}
     * @memberof CreateOrganizationResponse
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceRequest
 */
export interface CreateWorkspaceRequest {
    /**
     * 
     * @type {Workspace}
     * @memberof CreateWorkspaceRequest
     */
    'workspace'?: Workspace;
}
/**
 * 
 * @export
 * @interface CreateWorkspaceResponse
 */
export interface CreateWorkspaceResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof CreateWorkspaceResponse
     */
    'workspace'?: Workspace;
}
/**
 * 
 * @export
 * @interface CurrentUserResponse
 */
export interface CurrentUserResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof CurrentUserResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface DeleteIamUserResponse
 */
export interface DeleteIamUserResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof DeleteIamUserResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface Department
 */
export interface Department {
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Department
     */
    'description'?: string;
    /**
     * 
     * @type {Array<Employee>}
     * @memberof Department
     */
    'employees'?: Array<Employee>;
}
/**
 * 
 * @export
 * @interface EmailAddress
 */
export interface EmailAddress {
    /**
     * 
     * @type {string}
     * @memberof EmailAddress
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailAddress
     */
    'type'?: EmailAddressTypeEnum;
}

export const EmailAddressTypeEnum = {
    EmailTypeNotSpecified: 'EMAIL_TYPE_NOT_SPECIFIED',
    EmailTypePersonal: 'EMAIL_TYPE_PERSONAL',
    EmailTypeWork: 'EMAIL_TYPE_WORK',
    EmailTypeOther: 'EMAIL_TYPE_OTHER',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type EmailAddressTypeEnum = typeof EmailAddressTypeEnum[keyof typeof EmailAddressTypeEnum];

/**
 * 
 * @export
 * @interface Employee
 */
export interface Employee {
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'employeeId'?: string;
    /**
     * 
     * @type {FullName}
     * @memberof Employee
     */
    'name'?: FullName;
    /**
     * 
     * @type {string}
     * @memberof Employee
     */
    'title'?: string;
    /**
     * 
     * @type {Array<PhoneNumber>}
     * @memberof Employee
     */
    'phoneNumbers'?: Array<PhoneNumber>;
    /**
     * 
     * @type {Array<EmailAddress>}
     * @memberof Employee
     */
    'email'?: Array<EmailAddress>;
}
/**
 * 
 * @export
 * @interface FullName
 */
export interface FullName {
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'middleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullName
     */
    'suffix'?: string;
}
/**
 * 
 * @export
 * @interface GetIamUserResponse
 */
export interface GetIamUserResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof GetIamUserResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface GetOrganizationDetailsByIdResponse
 */
export interface GetOrganizationDetailsByIdResponse {
    /**
     * 
     * @type {Organization}
     * @memberof GetOrganizationDetailsByIdResponse
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface GetWorkspaceDetailsByIdResponse
 */
export interface GetWorkspaceDetailsByIdResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof GetWorkspaceDetailsByIdResponse
     */
    'workspace'?: Workspace;
}
/**
 * 
 * @export
 * @interface IamUser
 */
export interface IamUser {
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'systemName'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'username'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IamUser
     */
    'emailVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'status'?: IamUserStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'type'?: IamUserTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'organizationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'workspaceId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'modified'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUser
     */
    'modifier'?: string;
}

export const IamUserStatusEnum = {
    IamUserStatusUnspecified: 'IAM_USER_STATUS_UNSPECIFIED',
    IamUserStatusActive: 'IAM_USER_STATUS_ACTIVE',
    IamUserStatusInactive: 'IAM_USER_STATUS_INACTIVE',
    IamUserStatusDeleted: 'IAM_USER_STATUS_DELETED',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type IamUserStatusEnum = typeof IamUserStatusEnum[keyof typeof IamUserStatusEnum];
export const IamUserTypeEnum = {
    IamUserTypeUnspecified: 'IAM_USER_TYPE_UNSPECIFIED',
    IamUserTypeRegular: 'IAM_USER_TYPE_REGULAR',
    IamUserTypeSystem: 'IAM_USER_TYPE_SYSTEM',
    IamUserTypeTrial: 'IAM_USER_TYPE_TRIAL',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type IamUserTypeEnum = typeof IamUserTypeEnum[keyof typeof IamUserTypeEnum];

/**
 * 
 * @export
 * @interface ListIamUsersRequest
 */
export interface ListIamUsersRequest {
    /**
     * 
     * @type {Pagination}
     * @memberof ListIamUsersRequest
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface ListIamUsersResponse
 */
export interface ListIamUsersResponse {
    /**
     * 
     * @type {Pagination}
     * @memberof ListIamUsersResponse
     */
    'pagination'?: Pagination;
    /**
     * 
     * @type {Array<IamUser>}
     * @memberof ListIamUsersResponse
     */
    'iamUsers'?: Array<IamUser>;
}
/**
 * 
 * @export
 * @interface ListOrganizationsResponse
 */
export interface ListOrganizationsResponse {
    /**
     * 
     * @type {Array<Organization>}
     * @memberof ListOrganizationsResponse
     */
    'organizations'?: Array<Organization>;
}
/**
 * 
 * @export
 * @interface ListWorkspacesResponse
 */
export interface ListWorkspacesResponse {
    /**
     * 
     * @type {Array<Workspace>}
     * @memberof ListWorkspacesResponse
     */
    'workspaces'?: Array<Workspace>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'description'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof Organization
     */
    'foundingDate'?: Timestamp;
    /**
     * 
     * @type {Address}
     * @memberof Organization
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'industry'?: string;
    /**
     * 
     * @type {number}
     * @memberof Organization
     */
    'revenue'?: number;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Organization
     */
    'socialMediaLinks'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'missionStatement'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'visionStatement'?: string;
    /**
     * 
     * @type {Array<ContactInfo>}
     * @memberof Organization
     */
    'contacts'?: Array<ContactInfo>;
    /**
     * 
     * @type {Timestamp}
     * @memberof Organization
     */
    'created'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof Organization
     */
    'modified'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'modifier'?: string;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pagination
     */
    'sortAscending'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    'sort'?: string;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    'totalRecords'?: number;
}
/**
 * 
 * @export
 * @interface PhoneNumber
 */
export interface PhoneNumber {
    /**
     * 
     * @type {string}
     * @memberof PhoneNumber
     */
    'number'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhoneNumber
     */
    'type'?: PhoneNumberTypeEnum;
}

export const PhoneNumberTypeEnum = {
    PhoneTypeNotSpecified: 'PHONE_TYPE_NOT_SPECIFIED',
    PhoneTypeMobile: 'PHONE_TYPE_MOBILE',
    PhoneTypeHome: 'PHONE_TYPE_HOME',
    PhoneTypeWork: 'PHONE_TYPE_WORK',
    PhoneTypeFax: 'PHONE_TYPE_FAX',
    PhoneTypeOther: 'PHONE_TYPE_OTHER',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type PhoneNumberTypeEnum = typeof PhoneNumberTypeEnum[keyof typeof PhoneNumberTypeEnum];

/**
 * 
 * @export
 * @interface PrivacyProtectionData
 */
export interface PrivacyProtectionData {
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'anonymizedData'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PrivacyProtectionData
     */
    'isDataEncrypted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'encryptionMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'dataRetentionPolicy'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PrivacyProtectionData
     */
    'hasDataSharingAgreement'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PrivacyProtectionData
     */
    'dataPurpose'?: string;
}
/**
 * 
 * @export
 * @interface PrivacyProtectionDataRequest
 */
export interface PrivacyProtectionDataRequest {
    /**
     * 
     * @type {PrivacyProtectionData}
     * @memberof PrivacyProtectionDataRequest
     */
    'privacyProtectionData'?: PrivacyProtectionData;
}
/**
 * 
 * @export
 * @interface RealTimeMonitoringData
 */
export interface RealTimeMonitoringData {
    /**
     * 
     * @type {string}
     * @memberof RealTimeMonitoringData
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeMonitoringData
     */
    'monitoredEntity'?: string;
    /**
     * 
     * @type {string}
     * @memberof RealTimeMonitoringData
     */
    'monitoringDetails'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof RealTimeMonitoringData
     */
    'monitoringStartTime'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof RealTimeMonitoringData
     */
    'monitoringEndTime'?: Timestamp;
    /**
     * 
     * @type {Array<string>}
     * @memberof RealTimeMonitoringData
     */
    'triggeredAlerts'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RealTimeMonitoringData
     */
    'monitoringFrequency'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RealTimeMonitoringData
     */
    'isContinuousMonitoring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RealTimeMonitoringData
     */
    'responsibleMonitoringTeam'?: string;
}
/**
 * 
 * @export
 * @interface RealTimeMonitoringDataRequest
 */
export interface RealTimeMonitoringDataRequest {
    /**
     * 
     * @type {RealTimeMonitoringData}
     * @memberof RealTimeMonitoringDataRequest
     */
    'realTimeMonitoringData'?: RealTimeMonitoringData;
}
/**
 * 
 * @export
 * @interface SecurityResponse
 */
export interface SecurityResponse {
    /**
     * 
     * @type {string}
     * @memberof SecurityResponse
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityResponse
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'type'?: SignUpRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'systemName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'organizationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SignUpRequest
     */
    'workspaceId'?: string;
}

export const SignUpRequestTypeEnum = {
    IamUserTypeUnspecified: 'IAM_USER_TYPE_UNSPECIFIED',
    IamUserTypeRegular: 'IAM_USER_TYPE_REGULAR',
    IamUserTypeSystem: 'IAM_USER_TYPE_SYSTEM',
    IamUserTypeTrial: 'IAM_USER_TYPE_TRIAL',
    Unrecognized: 'UNRECOGNIZED'
} as const;

export type SignUpRequestTypeEnum = typeof SignUpRequestTypeEnum[keyof typeof SignUpRequestTypeEnum];

/**
 * 
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof SignUpResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface Timestamp
 */
export interface Timestamp {
    /**
     * 
     * @type {number}
     * @memberof Timestamp
     */
    'seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof Timestamp
     */
    'nanos'?: number;
}
/**
 * 
 * @export
 * @interface UpdateIamUserRequest
 */
export interface UpdateIamUserRequest {
    /**
     * 
     * @type {IamUser}
     * @memberof UpdateIamUserRequest
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface UpdateIamUserResponse
 */
export interface UpdateIamUserResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof UpdateIamUserResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {Organization}
     * @memberof UpdateOrganizationRequest
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface UpdateOrganizationResponse
 */
export interface UpdateOrganizationResponse {
    /**
     * 
     * @type {Organization}
     * @memberof UpdateOrganizationResponse
     */
    'organization'?: Organization;
}
/**
 * 
 * @export
 * @interface UpdateWorkspaceRequest
 */
export interface UpdateWorkspaceRequest {
    /**
     * 
     * @type {Workspace}
     * @memberof UpdateWorkspaceRequest
     */
    'workspace'?: Workspace;
}
/**
 * 
 * @export
 * @interface UpdateWorkspaceResponse
 */
export interface UpdateWorkspaceResponse {
    /**
     * 
     * @type {Workspace}
     * @memberof UpdateWorkspaceResponse
     */
    'workspace'?: Workspace;
}
/**
 * 
 * @export
 * @interface UserBehaviorAnalysisData
 */
export interface UserBehaviorAnalysisData {
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'encounterId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'behaviorPattern'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserBehaviorAnalysisData
     */
    'associatedActivities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'analysisTimeFrame'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserBehaviorAnalysisData
     */
    'historicalBehaviorData'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'riskAssessment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserBehaviorAnalysisData
     */
    'isBehaviorOutlier'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserBehaviorAnalysisData
     */
    'behaviorConsequence'?: string;
}
/**
 * 
 * @export
 * @interface UserBehaviorAnalysisDataRequest
 */
export interface UserBehaviorAnalysisDataRequest {
    /**
     * 
     * @type {UserBehaviorAnalysisData}
     * @memberof UserBehaviorAnalysisDataRequest
     */
    'userBehaviorAnalysisData'?: UserBehaviorAnalysisData;
}
/**
 * 
 * @export
 * @interface UserExistsRequest
 */
export interface UserExistsRequest {
    /**
     * 
     * @type {string}
     * @memberof UserExistsRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface UserExistsResponse
 */
export interface UserExistsResponse {
    /**
     * 
     * @type {IamUser}
     * @memberof UserExistsResponse
     */
    'iamUser'?: IamUser;
}
/**
 * 
 * @export
 * @interface Workspace
 */
export interface Workspace {
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'organizationId'?: string;
    /**
     * 
     * @type {Timestamp}
     * @memberof Workspace
     */
    'createdDate'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'location'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'manager'?: string;
    /**
     * 
     * @type {number}
     * @memberof Workspace
     */
    'capacity'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Workspace
     */
    'facilities'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'workspaceType'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Workspace
     */
    'workspaceImageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'usagePolicy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'availabilitySchedule'?: string;
    /**
     * 
     * @type {Array<Department>}
     * @memberof Workspace
     */
    'departments'?: Array<Department>;
    /**
     * 
     * @type {Timestamp}
     * @memberof Workspace
     */
    'created'?: Timestamp;
    /**
     * 
     * @type {Timestamp}
     * @memberof Workspace
     */
    'modified'?: Timestamp;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'creator'?: string;
    /**
     * 
     * @type {string}
     * @memberof Workspace
     */
    'modifier'?: string;
}

/**
 * OpenCdxRestProtectorControllerApi - axios parameter creator
 * @export
 */
export const OpenCdxRestProtectorControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserBehaviorAnalysisDataRequest} userBehaviorAnalysisDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnalyzeUserBehavior: async (userBehaviorAnalysisDataRequest: UserBehaviorAnalysisDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userBehaviorAnalysisDataRequest' is not null or undefined
            assertParamExists('postAnalyzeUserBehavior', 'userBehaviorAnalysisDataRequest', userBehaviorAnalysisDataRequest)
            const localVarPath = `/analyzeUserBehavior`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userBehaviorAnalysisDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthorizationControlDataRequest} authorizationControlDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorize: async (authorizationControlDataRequest: AuthorizationControlDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorizationControlDataRequest' is not null or undefined
            assertParamExists('postAuthorize', 'authorizationControlDataRequest', authorizationControlDataRequest)
            const localVarPath = `/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorizationControlDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AnomalyDetectionDataRequest} anomalyDetectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDetectAnomalies: async (anomalyDetectionDataRequest: AnomalyDetectionDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'anomalyDetectionDataRequest' is not null or undefined
            assertParamExists('postDetectAnomalies', 'anomalyDetectionDataRequest', anomalyDetectionDataRequest)
            const localVarPath = `/detectAnomalies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(anomalyDetectionDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RealTimeMonitoringDataRequest} realTimeMonitoringDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMonitorRealTime: async (realTimeMonitoringDataRequest: RealTimeMonitoringDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'realTimeMonitoringDataRequest' is not null or undefined
            assertParamExists('postMonitorRealTime', 'realTimeMonitoringDataRequest', realTimeMonitoringDataRequest)
            const localVarPath = `/monitorRealTime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(realTimeMonitoringDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PrivacyProtectionDataRequest} privacyProtectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProtectPrivacy: async (privacyProtectionDataRequest: PrivacyProtectionDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'privacyProtectionDataRequest' is not null or undefined
            assertParamExists('postProtectPrivacy', 'privacyProtectionDataRequest', privacyProtectionDataRequest)
            const localVarPath = `/protectPrivacy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(privacyProtectionDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdxRestProtectorControllerApi - functional programming interface
 * @export
 */
export const OpenCdxRestProtectorControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdxRestProtectorControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserBehaviorAnalysisDataRequest} userBehaviorAnalysisDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest: UserBehaviorAnalysisDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestProtectorControllerApi.postAnalyzeUserBehavior']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthorizationControlDataRequest} authorizationControlDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthorize(authorizationControlDataRequest: AuthorizationControlDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthorize(authorizationControlDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestProtectorControllerApi.postAuthorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AnomalyDetectionDataRequest} anomalyDetectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDetectAnomalies(anomalyDetectionDataRequest: AnomalyDetectionDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postDetectAnomalies(anomalyDetectionDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestProtectorControllerApi.postDetectAnomalies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RealTimeMonitoringDataRequest} realTimeMonitoringDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMonitorRealTime(realTimeMonitoringDataRequest: RealTimeMonitoringDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMonitorRealTime(realTimeMonitoringDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestProtectorControllerApi.postMonitorRealTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PrivacyProtectionDataRequest} privacyProtectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProtectPrivacy(privacyProtectionDataRequest: PrivacyProtectionDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProtectPrivacy(privacyProtectionDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxRestProtectorControllerApi.postProtectPrivacy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenCdxRestProtectorControllerApi - factory interface
 * @export
 */
export const OpenCdxRestProtectorControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdxRestProtectorControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {UserBehaviorAnalysisDataRequest} userBehaviorAnalysisDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest: UserBehaviorAnalysisDataRequest, options?: any): AxiosPromise<SecurityResponse> {
            return localVarFp.postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthorizationControlDataRequest} authorizationControlDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthorize(authorizationControlDataRequest: AuthorizationControlDataRequest, options?: any): AxiosPromise<SecurityResponse> {
            return localVarFp.postAuthorize(authorizationControlDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AnomalyDetectionDataRequest} anomalyDetectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDetectAnomalies(anomalyDetectionDataRequest: AnomalyDetectionDataRequest, options?: any): AxiosPromise<SecurityResponse> {
            return localVarFp.postDetectAnomalies(anomalyDetectionDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RealTimeMonitoringDataRequest} realTimeMonitoringDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMonitorRealTime(realTimeMonitoringDataRequest: RealTimeMonitoringDataRequest, options?: any): AxiosPromise<SecurityResponse> {
            return localVarFp.postMonitorRealTime(realTimeMonitoringDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PrivacyProtectionDataRequest} privacyProtectionDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProtectPrivacy(privacyProtectionDataRequest: PrivacyProtectionDataRequest, options?: any): AxiosPromise<SecurityResponse> {
            return localVarFp.postProtectPrivacy(privacyProtectionDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdxRestProtectorControllerApi - object-oriented interface
 * @export
 * @class OpenCdxRestProtectorControllerApi
 * @extends {BaseAPI}
 */
export class OpenCdxRestProtectorControllerApi extends BaseAPI {
    /**
     * 
     * @param {UserBehaviorAnalysisDataRequest} userBehaviorAnalysisDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestProtectorControllerApi
     */
    public postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest: UserBehaviorAnalysisDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestProtectorControllerApiFp(this.configuration).postAnalyzeUserBehavior(userBehaviorAnalysisDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthorizationControlDataRequest} authorizationControlDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestProtectorControllerApi
     */
    public postAuthorize(authorizationControlDataRequest: AuthorizationControlDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestProtectorControllerApiFp(this.configuration).postAuthorize(authorizationControlDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AnomalyDetectionDataRequest} anomalyDetectionDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestProtectorControllerApi
     */
    public postDetectAnomalies(anomalyDetectionDataRequest: AnomalyDetectionDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestProtectorControllerApiFp(this.configuration).postDetectAnomalies(anomalyDetectionDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RealTimeMonitoringDataRequest} realTimeMonitoringDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestProtectorControllerApi
     */
    public postMonitorRealTime(realTimeMonitoringDataRequest: RealTimeMonitoringDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestProtectorControllerApiFp(this.configuration).postMonitorRealTime(realTimeMonitoringDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PrivacyProtectionDataRequest} privacyProtectionDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxRestProtectorControllerApi
     */
    public postProtectPrivacy(privacyProtectionDataRequest: PrivacyProtectionDataRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxRestProtectorControllerApiFp(this.configuration).postProtectPrivacy(privacyProtectionDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OpenCdxiamOrganizationRestControllerApi - axios parameter creator
 * @export
 */
export const OpenCdxiamOrganizationRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: async (createOrganizationRequest: CreateOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationRequest' is not null or undefined
            assertParamExists('createOrganization', 'createOrganizationRequest', createOrganizationRequest)
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDetailsById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganizationDetailsById', 'id', id)
            const localVarPath = `/organization/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/organization/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: async (updateOrganizationRequest: UpdateOrganizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateOrganizationRequest' is not null or undefined
            assertParamExists('updateOrganization', 'updateOrganizationRequest', updateOrganizationRequest)
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrganizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdxiamOrganizationRestControllerApi - functional programming interface
 * @export
 */
export const OpenCdxiamOrganizationRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdxiamOrganizationRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrganization(createOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamOrganizationRestControllerApi.createOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrganizationDetailsById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationDetailsByIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrganizationDetailsById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamOrganizationRestControllerApi.getOrganizationDetailsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrganizations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListOrganizationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrganizations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamOrganizationRestControllerApi.listOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateOrganizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrganization(updateOrganizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamOrganizationRestControllerApi.updateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenCdxiamOrganizationRestControllerApi - factory interface
 * @export
 */
export const OpenCdxiamOrganizationRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdxiamOrganizationRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationRequest} createOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: any): AxiosPromise<CreateOrganizationResponse> {
            return localVarFp.createOrganization(createOrganizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationDetailsById(id: string, options?: any): AxiosPromise<GetOrganizationDetailsByIdResponse> {
            return localVarFp.getOrganizationDetailsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganizations(options?: any): AxiosPromise<ListOrganizationsResponse> {
            return localVarFp.listOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateOrganizationRequest} updateOrganizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: any): AxiosPromise<UpdateOrganizationResponse> {
            return localVarFp.updateOrganization(updateOrganizationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdxiamOrganizationRestControllerApi - object-oriented interface
 * @export
 * @class OpenCdxiamOrganizationRestControllerApi
 * @extends {BaseAPI}
 */
export class OpenCdxiamOrganizationRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrganizationRequest} createOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamOrganizationRestControllerApi
     */
    public createOrganization(createOrganizationRequest: CreateOrganizationRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamOrganizationRestControllerApiFp(this.configuration).createOrganization(createOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamOrganizationRestControllerApi
     */
    public getOrganizationDetailsById(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxiamOrganizationRestControllerApiFp(this.configuration).getOrganizationDetailsById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamOrganizationRestControllerApi
     */
    public listOrganizations(options?: RawAxiosRequestConfig) {
        return OpenCdxiamOrganizationRestControllerApiFp(this.configuration).listOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateOrganizationRequest} updateOrganizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamOrganizationRestControllerApi
     */
    public updateOrganization(updateOrganizationRequest: UpdateOrganizationRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamOrganizationRestControllerApiFp(this.configuration).updateOrganization(updateOrganizationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OpenCdxiamUserRestControllerApi - axios parameter creator
 * @export
 */
export const OpenCdxiamUserRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordRequest: ChangePasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordRequest' is not null or undefined
            assertParamExists('changePassword', 'changePasswordRequest', changePasswordRequest)
            const localVarPath = `/user/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIamUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIamUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIamUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIamUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListIamUsersRequest} listIamUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIamUsers: async (listIamUsersRequest: ListIamUsersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listIamUsersRequest' is not null or undefined
            assertParamExists('listIamUsers', 'listIamUsersRequest', listIamUsersRequest)
            const localVarPath = `/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listIamUsersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (signUpRequest: SignUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpRequest' is not null or undefined
            assertParamExists('signUp', 'signUpRequest', signUpRequest)
            const localVarPath = `/user/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateIamUserRequest} updateIamUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIamUser: async (updateIamUserRequest: UpdateIamUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateIamUserRequest' is not null or undefined
            assertParamExists('updateIamUser', 'updateIamUserRequest', updateIamUserRequest)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateIamUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserExistsRequest} userExistsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExists: async (userExistsRequest: UserExistsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userExistsRequest' is not null or undefined
            assertParamExists('userExists', 'userExistsRequest', userExistsRequest)
            const localVarPath = `/user/exists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userExistsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailIamUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('verifyEmailIamUser', 'id', id)
            const localVarPath = `/user/verify/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdxiamUserRestControllerApi - functional programming interface
 * @export
 */
export const OpenCdxiamUserRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdxiamUserRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePasswordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.currentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIamUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteIamUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIamUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.deleteIamUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIamUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIamUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIamUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.getIamUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListIamUsersRequest} listIamUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIamUsers(listIamUsersRequest: ListIamUsersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListIamUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIamUsers(listIamUsersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.listIamUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUp(signUpRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.signUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateIamUserRequest} updateIamUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIamUser(updateIamUserRequest: UpdateIamUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateIamUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIamUser(updateIamUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.updateIamUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserExistsRequest} userExistsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userExists(userExistsRequest: UserExistsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userExists(userExistsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.userExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmailIamUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmailIamUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamUserRestControllerApi.verifyEmailIamUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenCdxiamUserRestControllerApi - factory interface
 * @export
 */
export const OpenCdxiamUserRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdxiamUserRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ChangePasswordRequest} changePasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordRequest: ChangePasswordRequest, options?: any): AxiosPromise<ChangePasswordResponse> {
            return localVarFp.changePassword(changePasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUser(options?: any): AxiosPromise<CurrentUserResponse> {
            return localVarFp.currentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIamUser(id: string, options?: any): AxiosPromise<DeleteIamUserResponse> {
            return localVarFp.deleteIamUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIamUser(id: string, options?: any): AxiosPromise<GetIamUserResponse> {
            return localVarFp.getIamUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListIamUsersRequest} listIamUsersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIamUsers(listIamUsersRequest: ListIamUsersRequest, options?: any): AxiosPromise<ListIamUsersResponse> {
            return localVarFp.listIamUsers(listIamUsersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignUpRequest} signUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(signUpRequest: SignUpRequest, options?: any): AxiosPromise<SignUpResponse> {
            return localVarFp.signUp(signUpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateIamUserRequest} updateIamUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIamUser(updateIamUserRequest: UpdateIamUserRequest, options?: any): AxiosPromise<UpdateIamUserResponse> {
            return localVarFp.updateIamUser(updateIamUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserExistsRequest} userExistsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExists(userExistsRequest: UserExistsRequest, options?: any): AxiosPromise<UserExistsResponse> {
            return localVarFp.userExists(userExistsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailIamUser(id: string, options?: any): AxiosPromise<string> {
            return localVarFp.verifyEmailIamUser(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdxiamUserRestControllerApi - object-oriented interface
 * @export
 * @class OpenCdxiamUserRestControllerApi
 * @extends {BaseAPI}
 */
export class OpenCdxiamUserRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {ChangePasswordRequest} changePasswordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public changePassword(changePasswordRequest: ChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).changePassword(changePasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public currentUser(options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).currentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public deleteIamUser(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).deleteIamUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public getIamUser(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).getIamUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListIamUsersRequest} listIamUsersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public listIamUsers(listIamUsersRequest: ListIamUsersRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).listIamUsers(listIamUsersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignUpRequest} signUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public signUp(signUpRequest: SignUpRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).signUp(signUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateIamUserRequest} updateIamUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public updateIamUser(updateIamUserRequest: UpdateIamUserRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).updateIamUser(updateIamUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserExistsRequest} userExistsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public userExists(userExistsRequest: UserExistsRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).userExists(userExistsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamUserRestControllerApi
     */
    public verifyEmailIamUser(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxiamUserRestControllerApiFp(this.configuration).verifyEmailIamUser(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OpenCdxiamWorkspaceRestControllerApi - axios parameter creator
 * @export
 */
export const OpenCdxiamWorkspaceRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace: async (createWorkspaceRequest: CreateWorkspaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkspaceRequest' is not null or undefined
            assertParamExists('createWorkspace', 'createWorkspaceRequest', createWorkspaceRequest)
            const localVarPath = `/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDetailsById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkspaceDetailsById', 'id', id)
            const localVarPath = `/workspace/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/workspace/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateWorkspaceRequest} updateWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace: async (updateWorkspaceRequest: UpdateWorkspaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateWorkspaceRequest' is not null or undefined
            assertParamExists('updateWorkspace', 'updateWorkspaceRequest', updateWorkspaceRequest)
            const localVarPath = `/workspace`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkspaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdxiamWorkspaceRestControllerApi - functional programming interface
 * @export
 */
export const OpenCdxiamWorkspaceRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdxiamWorkspaceRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkspace(createWorkspaceRequest: CreateWorkspaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkspace(createWorkspaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamWorkspaceRestControllerApi.createWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkspaceDetailsById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkspaceDetailsByIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkspaceDetailsById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamWorkspaceRestControllerApi.getWorkspaceDetailsById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWorkspaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWorkspacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWorkspaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamWorkspaceRestControllerApi.listWorkspaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateWorkspaceRequest} updateWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkspace(updateWorkspaceRequest: UpdateWorkspaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkspaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkspace(updateWorkspaceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OpenCdxiamWorkspaceRestControllerApi.updateWorkspace']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OpenCdxiamWorkspaceRestControllerApi - factory interface
 * @export
 */
export const OpenCdxiamWorkspaceRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdxiamWorkspaceRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateWorkspaceRequest} createWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkspace(createWorkspaceRequest: CreateWorkspaceRequest, options?: any): AxiosPromise<CreateWorkspaceResponse> {
            return localVarFp.createWorkspace(createWorkspaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkspaceDetailsById(id: string, options?: any): AxiosPromise<GetWorkspaceDetailsByIdResponse> {
            return localVarFp.getWorkspaceDetailsById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkspaces(options?: any): AxiosPromise<ListWorkspacesResponse> {
            return localVarFp.listWorkspaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateWorkspaceRequest} updateWorkspaceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkspace(updateWorkspaceRequest: UpdateWorkspaceRequest, options?: any): AxiosPromise<UpdateWorkspaceResponse> {
            return localVarFp.updateWorkspace(updateWorkspaceRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdxiamWorkspaceRestControllerApi - object-oriented interface
 * @export
 * @class OpenCdxiamWorkspaceRestControllerApi
 * @extends {BaseAPI}
 */
export class OpenCdxiamWorkspaceRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateWorkspaceRequest} createWorkspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamWorkspaceRestControllerApi
     */
    public createWorkspace(createWorkspaceRequest: CreateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamWorkspaceRestControllerApiFp(this.configuration).createWorkspace(createWorkspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamWorkspaceRestControllerApi
     */
    public getWorkspaceDetailsById(id: string, options?: RawAxiosRequestConfig) {
        return OpenCdxiamWorkspaceRestControllerApiFp(this.configuration).getWorkspaceDetailsById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamWorkspaceRestControllerApi
     */
    public listWorkspaces(options?: RawAxiosRequestConfig) {
        return OpenCdxiamWorkspaceRestControllerApiFp(this.configuration).listWorkspaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateWorkspaceRequest} updateWorkspaceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdxiamWorkspaceRestControllerApi
     */
    public updateWorkspace(updateWorkspaceRequest: UpdateWorkspaceRequest, options?: RawAxiosRequestConfig) {
        return OpenCdxiamWorkspaceRestControllerApiFp(this.configuration).updateWorkspace(updateWorkspaceRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



